<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="$(SolutionDir)/Freedom.DomainGenerator/Freedom.DomainGenerator/bin/$(Configuration)/Freedom.DomainGenerator.Dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="Freedom.DomainGenerator" #>
<#@ import namespace="Freedom.DomainGenerator.DomainDefinitionModel" #>
<#@ import namespace="Freedom.DomainGenerator.TextTemplate" #>
<#

	TemplateFileManager fileManager = TemplateFileManager.Create(this);

	Domain domain = DomainBuilder.Load(Host.ResolvePath(@"Definition\FreedomDomain.xml"));

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using Freedom.Annotations;
using Freedom.FullTextSearch;

namespace Freedom.Domain.Model
{
	[DataContract(IsReference = true, Namespace = Namespace)]
<#
	foreach (EntityType entityType in domain.EntityTypes.Where(et => et.BaseType == null))
	{
#>
	[KnownType(typeof(<#= entityType.Name #>))]
<#
	}
#>
	public abstract partial class Entity 
	{
		public const string Namespace = "<#= domain.Namespace #>";

		[Browsable(false)]
		public DateTime? AuditStartDateTime { get; set; }

		[Browsable(false)]
		public DateTime? AuditEndDateTime { get; set; }

		[Browsable(false)]
		[IndexHint(IndexHints.Ignore)]
		public abstract string EntityTypeName { get; }

		#region Serialization

		[Browsable(false)]
		protected bool IsSerializing { get; set; }

		[OnSerializing]
		private void OnSerializing(StreamingContext context)
		{
			IsSerializing = true;
		}
		
		[OnSerialized]
		private void OnSerialized(StreamingContext context)
		{
			IsSerializing = false;
		}
		
		#endregion
	}
	
	public abstract partial class EntityBase : INotifyPropertyChanged
	{
		#region Date Validation / Conversion

		protected DateTime ValidateDate(DateTime date)
		{
			Debug.Assert(date.TimeOfDay == TimeSpan.Zero, "Expected a date without a time component");

			return DateTime.SpecifyKind(date.Date, DateTimeKind.Utc);
		}

		protected DateTime? ValidateDate(DateTime? date)
		{
			return date.HasValue ? ValidateDate(date.Value) : (DateTime?)null;
		}

		#endregion

		#region Entity State (Change Tracking)

		[Browsable(false)]
		[DataMember(EmitDefaultValue = false)]
		[DefaultValue(EntityState.Unchanged)]
		public EntityState State { get; protected internal set; } = EntityState.Added;

		protected internal bool TrackChanges { get; set; }

		protected internal virtual void MarkAsChanged()
		{
			if (TrackChanges && State == EntityState.Unchanged)
				State = EntityState.Modified;
		}

		[OnDeserialized]
		private void OnDeserialized(StreamingContext context)
		{
			TrackChanges = true;
		}

		#endregion

		#region Implementation of INotifyPropertyChanged

		public event PropertyChangedEventHandler PropertyChanged;

		[NotifyPropertyChangedInvocator]
		public void OnPropertyChanged([CallerMemberName] string propertyName = null)
		{
			OnPropertyChanged(new PropertyChangedEventArgs(propertyName));
		}

		protected virtual void OnPropertyChanged(PropertyChangedEventArgs args)
		{
			if (args == null)
				throw new ArgumentNullException(nameof(args));

			PropertyChanged?.Invoke(this, args);
		}

		#endregion

		#region Overrides of object

		public override string ToString()
		{
			return $"{GetType().Name} - {Id}";
		}

		#endregion
	}

	[CollectionDataContract(Namespace = Entity.Namespace)]
	public class EntityCollection<T> : ObservableCollection<T>
	{
		public EntityCollection()
		{
		}

		public EntityCollection([NotNull] IEnumerable<T> collection)
			: base(collection)
		{
		}

		public void AddRange([NotNull] IEnumerable<T> collection)
		{
			if (collection == null)
				throw new ArgumentNullException("collection");

			foreach (T item in collection)
				Add(item);
		}
	}
}
<#
	foreach(EntityType entityType in domain.EntityTypes)
	{
		fileManager.StartNewFile(entityType.Name + ".generated.cs");
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using Freedom.Domain.Infrastructure;
using Freedom.Domain.Services.Repository;
using Freedom.ComponentModel;

namespace Freedom.Domain.Model
{
	[DataContract(Namespace = Namespace)]
<#
	foreach (string knownType in entityType.GetKnownTypes())
	{
#>
	[KnownType(typeof(<#= knownType #>))]
<#
	}
#>
<#
	if (entityType.Reportable != null)
	{
		if (entityType.Reportable == bool.TrueString)
		{
#>
	[Reportable]
<#
		}
		else
		{
#>
	[Reportable(false)]
<#
		}
	}
#>

	public <#= entityType.Abstract ? "abstract " : ""#>partial class <#= entityType.Name #> : <#= entityType.BaseType ?? "Entity" #>
	{
<#
		if (entityType.IsAggregateRoot)
		{
			List<string> childPaths = entityType.GetChildPaths().ToList();

			if (childPaths.Count > 0)
			{
#>
		public static readonly ResolutionGraph DefaultResolutionGraph = new ResolutionGraph(
<#
				for (int i = 0; i < childPaths.Count; i++)
				{
#>
			Paths.<#= entityType.Name #>.<#= childPaths[i] #><#= i + 1 < childPaths.Count ? "," : "" #>
<#	
				}
#>
		);

<#		
			}
		}
#>
<#
		if (entityType.IsManyToManyIntermediate)
		{
			Relationship toParent = entityType.Relationships.Single(r => r.RelationshipType == RelationshipType.Parent);
			Relationship toRelated = entityType.Relationships.Single(r => r.RelationshipType == RelationshipType.Required);

#>
		public <#= entityType.Name #>()
		{
		}

		public <#= entityType.Name #>(Guid <#= toParent.FieldName.Trim('_') #>Id, Guid <#= toRelated.FieldName.Trim('_') #>Id)
			: this()
		{
			<#= toParent.FieldName #>Id = <#= toParent.FieldName.Trim('_') #>Id;
			<#= toRelated.FieldName #>Id = <#= toRelated.FieldName.Trim('_') #>Id;
		}

<#
		}
#>
<#
		if (!entityType.Abstract)
		{
#>
		public override string EntityTypeName
		{
			get { return "<#= entityType.Name #>"; }
		}

<#
		}
#>
<#
		foreach(Property property in entityType.Properties.Where(p => !p.IsComplexType))
		{
			if (property.Flags.HasFlag(PropertyFlags.StorageOnly)) continue;
#>
		[DataMember(EmitDefaultValue = false)]
<#
			if (property.Name != property.DatabaseColumnName)
			{
#>
		[Column("<#= property.DatabaseColumnName #>")]
<#
			}
#>
		public <#= property.ClrType #> <#= property.Name #>
		{
			get { return <#= property.FieldName #>; }
<#
			if (entityType.BaseType == null && entityType.Name != "EntityBase")
			{
#>
			set { <#= property.FieldName #> = value; }
<#
			}
			else
			{
#>
			set
			{
				if (<#= property.FieldName #> == value) return;
<#
			if (property.Type == "Date")
			{
#>
				<#= property.FieldName #> = ValidateDate(value);
<#
			}
			else
			{
#>
				<#= property.FieldName #> = value;
<#
			}
#>
				MarkAsChanged();
				OnPropertyChanged();
			}
<#
			}
#>
		}
		private <#= property.ClrType #> <#= property.FieldName #><#= property.GetClrFieldInitializer() #>;

<#
		}
#>
<#
		foreach(Property property in entityType.Properties.Where(p => p.IsComplexType))
		{
#>
		[DataMember(EmitDefaultValue = false)]
		public <#= property.ClrType #> <#= property.Name #>
		{
			get
			{
				if (!IsSerializing && <#= property.FieldName #> == null)
				{
					<#= property.FieldName #> = new <#= property.ClrType #>();
					<#= property.FieldName #>.PropertyChanged += Handle<#= property.Name #>Changed;
				}
				return <#= property.FieldName #>;
			}
			set
			{
				if (<#= property.FieldName #> != value)
				{
					if (<#= property.FieldName #> != null)
						<#= property.FieldName #>.PropertyChanged -= Handle<#= property.Name #>Changed;

					if (value != null)
						value.PropertyChanged += Handle<#= property.Name #>Changed;

					<#= property.FieldName #> = value;

					MarkAsChanged();
					OnPropertyChanged();
				}
			}
		}
		private <#= property.ClrType #> <#= property.FieldName #>;

		private void Handle<#= property.Name #>Changed(object sender, PropertyChangedEventArgs args)
		{
			MarkAsChanged();
			OnPropertyChanged("<#= property.Name #>");
		}

<#
		}
#>
<#
		for (EntityType subType = entityType; subType != null; subType = subType.BaseEntityType)
		{
			foreach(Relationship relationship in subType.Relationships.Where(r => !r.IsCollection))
			{
				if (entityType.Abstract && subType == entityType)
				{
#>
		[DataMember(EmitDefaultValue = false)]
		public abstract <#= relationship.RelatedType #> <#= relationship.Name #> { get; set; }

<#
				}

				if (!entityType.Abstract)
				{

#>
		[DataMember(EmitDefaultValue = false)]
		public <#= subType == entityType ? "virtual" : "override" #> <#= relationship.RelatedType #> <#= relationship.Name #>
		{
			get { return <#= relationship.FieldName #>; }
			set
			{
				if (object.ReferenceEquals(<#= relationship.FieldName #>, value)) return;

				<#= relationship.FieldName #> = value;

				if (value != null)
					<#= relationship.Name #>Id = value.Id;
<#
					if (entityType.BaseType != null)
					{
#>

				OnPropertyChanged();
<#
					}
#>
			}
		}
		private <#= relationship.RelatedType #> <#= relationship.FieldName #>;

<#
				}
			}
		}
 
		foreach(Relationship relationship in entityType.Relationships.Where(r => r.IsCollection))
		{
			if (relationship.RelationshipType == RelationshipType.ManyToMany) continue;
			if (relationship.RelatedEntityType.IsManyToManyIntermediate) continue;

#>
		[DataMember(EmitDefaultValue = false)]
		public virtual IList<<#= relationship.RelatedType #>> <#= relationship.Name #>
		{
			get
			{
				if (!IsSerializing && <#= relationship.FieldName #> == null)
				{
					<#= relationship.FieldName #> = new EntityCollection<<#= relationship.RelatedType #>>();
					<#= relationship.FieldName #>.CollectionChanged += (s, a) => MarkAsChanged();
				}

				return <#= relationship.FieldName #>;
			}
			set
			{
				if (!object.ReferenceEquals(<#= relationship.FieldName #>, value))
				{
					if (value != null)
					{
						if (<#= relationship.FieldName #> == null)
						{
							<#= relationship.FieldName #> = new EntityCollection<<#= relationship.RelatedType #>>(value);
							<#= relationship.FieldName #>.CollectionChanged += (s, a) => MarkAsChanged();
						}
						else
						{
							<#= relationship.FieldName #>.Clear();
							<#= relationship.FieldName #>.AddRange(value);
						}
					}
					else if (<#= relationship.FieldName #> != null)
					{
						<#= relationship.FieldName #>.Clear();
					}

					MarkAsChanged();
					OnPropertyChanged();
				}
			}
		}
		private EntityCollection<<#= relationship.RelatedType #>> <#= relationship.FieldName #>;

<#
		}

		foreach(Relationship relationship in entityType.Relationships.Where(r => r.RelationshipType == RelationshipType.ManyToMany))
		{
#>
		[DataMember(EmitDefaultValue = false)]
		public virtual ICollection<Guid> <#= relationship.RelatedType #>Ids
		{
			get
			{
				if (<#= relationship.RelatedType.ToFieldName() #>Ids == null)
				{
					if (<#= relationship.Intermediate.ToFieldName() #> != null)
					{
						<#= relationship.RelatedType.ToFieldName() #>Ids = new KeySetCollection<<#= relationship.Intermediate #>>(<#= relationship.Intermediate.ToFieldName() #>, x => x.<#= relationship.RelatedType #>Id);
					}
					else if (!IsSerializing)
					{
						ObservableHashSet<Guid> hashSet = new ObservableHashSet<Guid>();
						hashSet.CollectionChanged += (s, a) => MarkAsChanged();
						<#= relationship.RelatedType.ToFieldName() #>Ids = hashSet;
					}
				}
				return <#= relationship.RelatedType.ToFieldName() #>Ids;
			}
			set
			{
				if (!object.ReferenceEquals(<#= relationship.RelatedType #>Ids, value))
				{
					KeySetCollection<<#= relationship.Intermediate #>> keySet = <#= relationship.RelatedType.ToFieldName() #>Ids as KeySetCollection<<#= relationship.Intermediate #>>;

					if (keySet != null)
					{
						keySet.ReplaceWith(value);
					}
					else
					{
						<#= relationship.RelatedType.ToFieldName() #>Ids.Clear();

						if (value != null && value.Count > 0)
							foreach(Guid id in value)
								<#= relationship.RelatedType.ToFieldName() #>Ids.Add(id);
					}

					OnPropertyChanged();
				}
			}
		}
		private ICollection<Guid> <#= relationship.RelatedType.ToFieldName() #>Ids;

		[Browsable(false)]  // Intermediate Collection
		public virtual IList<<#= relationship.Intermediate #>> <#= relationship.Intermediate #>
		{
			get
			{
				if (<#= relationship.Intermediate.ToFieldName() #> == null)
					<#= relationship.Intermediate.ToFieldName() #> = new List<<#= relationship.Intermediate #>>();

				return <#= relationship.Intermediate.ToFieldName() #>;
			}
			set
			{
				if (!object.ReferenceEquals(<#= relationship.Intermediate.ToFieldName() #>, value))
				{
					if (value != null && value.Count > 0)
					{
						if (<#= relationship.Intermediate.ToFieldName() #> == null)
						{
							<#= relationship.Intermediate.ToFieldName() #> = new List<<#= relationship.Intermediate #>>(value);
						}
						else
						{
							<#= relationship.Intermediate.ToFieldName() #>.Clear();
							<#= relationship.Intermediate.ToFieldName() #>.AddRange(value);
						}
					}
					else if (<#= relationship.Intermediate.ToFieldName() #> != null)
					{
						<#= relationship.Intermediate.ToFieldName() #>.Clear();
					}

					OnPropertyChanged();
				}
			}
		}
		private List<<#= relationship.Intermediate #>> <#= relationship.Intermediate.ToFieldName() #>;

		public virtual CompositeCollection<<#= relationship.Intermediate #>, <#= relationship.RelatedType #>> <#= relationship.Name #>
		{
			get
			{
				if  (<#= relationship.FieldName #> == null)
				{
				    Debug.Assert(Assembly.GetEntryAssembly().FullName.Contains("Freedom.ReportEngine"),
				        "Composite many-to-many collections on entities should only every be accessed when running a report.");

					<#= relationship.FieldName #> = new CompositeCollection<<#= relationship.Intermediate #>, <#= relationship.RelatedType #>>(
						<#= relationship.Intermediate #>, x => x.<#= relationship.RelatedType #>, x => x.<#= relationship.RelatedType #>Id);
				}

				return <#= relationship.FieldName #>;
			}
		}
		private CompositeCollection<<#= relationship.Intermediate #>, <#= relationship.RelatedType #>> <#= relationship.FieldName #>;

<#
		}
#>
		public <#= entityType.BaseType == null ? "virtual" : "override" #> void Copy(Entity entity)
		{
<#
		if (entityType.BaseType != null)
		{
#>
			base.Copy(entity);

<#
		}
#>
			<#= entityType.Name #> source = entity as <#= entityType.Name #>;

			if (source == null)
				throw new ArgumentException("entity", "entity must be an instance of <#= entityType.Name #>.");

<#
		foreach (Property property in entityType.Properties)
		{
			if (property.Flags.HasFlag(PropertyFlags.Independant)) continue;
			if (property.Flags.HasFlag(PropertyFlags.StorageOnly)) continue;
#>
			<#= property.Name #> = source.<#= property.FieldName #>;
<#
		}
#>
		}
	}
}
<#	
	}

	fileManager.Process();
#>